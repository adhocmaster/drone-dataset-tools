for i in range(1, 61):
    dataset_id = i
    current_file = read_highD_data(dataset_id, path_dict, outputDir)
    current_file.tracksMeta.columns
    df = current_file.tracksMeta
    ego_type = 'Car'
    preceding_type = 'Car'
    thw_lower = 0
    thw_upper = 0.1

    car_follow = current_file.filter_car_following(ego_type,
                                                preceding_type,
                                                thw_lower,
                                                thw_upper)
    print(len(car_follow))
    # for i in range(len(car_follow)):
    #     ego_id = car_follow[i]['ego_id']
    #     pred_id = car_follow[i]['pred_id']

    #     video_name = 'car_follow_' + str(ego_id)

    #     start = car_follow[i]['following_start']
    #     end = car_follow[i]['following_end']

    #     print(video_name, start, end)
    #     current_file.create_video_from_frames(start, end, 25, video_name, ego_id)






























        #  processing fucntions
    
    # def process_tracksMeta(self):
    #     df = self.tracksMeta
    #     static_dictionary = {}
    #     for i_row in range(df.shape[0]):
    #         track_id = int(df['id'][i_row])
    #         static_dictionary[track_id] = {'id': track_id,
    #                                        'width': int(df[WIDTH][i_row]),
    #                                        'height': int(df[HEIGHT][i_row]),
    #                                        'initialFrame': int(df[INITIAL_FRAME][i_row]),
    #                                        'finalFrame': int(df[FINAL_FRAME][i_row]),
    #                                        'numFrames': int(df[NUM_FRAMES][i_row]),
    #                                        'class': str(df[CLASS][i_row]),
    #                                        'drivingDirection': float(df[DRIVING_DIRECTION][i_row]),
    #                                        'traveledDistance': float(df[TRAVELED_DISTANCE][i_row]),
    #                                        'minXVelocity': float(df[MIN_X_VELOCITY][i_row]),
    #                                        'maxXVelocity': float(df[MAX_X_VELOCITY][i_row]),
    #                                        'meanXVelocity': float(df[MEAN_X_VELOCITY][i_row]),
    #                                        'minDHW': float(df[MIN_TTC][i_row]),
    #                                        'minTHW': float(df[MIN_THW][i_row]),
    #                                        'minTTC': float(df[MIN_DHW][i_row]),
    #                                        'numLaneChanges': int(df[NUMBER_LANE_CHANGES][i_row]),
    #                                        }
    #     return static_dictionary

    # def process_tracks(self):

    #     df = self.tracks
    #     grouped = df.groupby([TRACK_ID], sort=False)
    #     # Efficiently pre-allocate an empty list of sufficient size
    #     tracks = [None] * grouped.ngroups
    #     current_track = 0
    #     for group_id, rows in grouped:
    #         bounding_boxes = np.transpose(np.array([rows['x'].values,
    #                                                 rows['y'].values,
    #                                                 rows['width'].values,
    #                                                 rows['height'].values]))
    #         tracks[current_track] = {'id': np.int64(group_id),  # for compatibility, int would be more space efficient
    #                                  'frame': rows[FRAME].values,
    #                                  'bbox': bounding_boxes,
    #                                  'xVelocity': rows['xVelocity'].values,
    #                                  'yVelocity': rows['yVelocity'].values,
    #                                  'xAcceleration': rows['xAcceleration'].values,
    #                                  'yAcceleration': rows['yAcceleration'].values,
    #                                  'frontSightDistance': rows['frontSightDistance'].values,
    #                                  'backSightDistance': rows['backSightDistance'].values,
    #                                  'thw': rows['thw'].values,
    #                                  'ttc': rows['ttc'].values,
    #                                  'dhw': rows['dhw'].values,
    #                                  'precedingXVelocity': rows['precedingXVelocity'].values,
    #                                  'precedingId': rows['precedingId'].values,
    #                                  'followingId': rows['followingId'].values,
    #                                  'leftFollowingId': rows['leftFollowingId'].values,
    #                                  'leftAlongsideId': rows['leftAlongsideId'].values,
    #                                  'leftPrecedingId': rows['leftPrecedingId'].values,
    #                                  'rightFollowingId': rows['rightFollowingId'].values,
    #                                  'rightAlongsideId': rows['rightAlongsideId'].values,
    #                                  'rightPrecedingId': rows['rightPrecedingId'].values,
    #                                  'laneId': rows['laneId'].values
    #                                  }
    #         current_track = current_track + 1
    #     return tracks


    # def process_recordingMeta(self):

    #     df = self.recordingMeta

    #     extracted_meta_dictionary = {'id': int(df['id'][0]),
    #                              'frameRate': int(df['frameRate'][0]),
    #                              'locationId': int(df['locationId'][0]),
    #                              'speedLimit': float(df['speedLimit'][0]),
    #                              'month': str(df['month'][0]),
    #                              'weekDay': str(df['weekDay'][0]),
    #                              'startTime': str(df['startTime'][0]),
    #                              'duration': float(df['duration'][0]),
    #                              'totalDrivenDistance': float(df['totalDrivenDistance'][0]),
    #                              'totalDrivenTime': float(df['totalDrivenTime'][0]),
    #                              'numVehicles': int(df['numVehicles'][0]),
    #                              'numCars': int(df['numCars'][0]),
    #                              'numTrucks': int(df['numTrucks'][0]),
    #                              'upperLaneMarkings': np.fromstring(df['upperLaneMarkings'][0], sep=";"),
    #                              'lowerLaneMarkings': np.fromstring(df['lowerLaneMarkings'][0], sep=";")}

    #     return extracted_meta_dictionary
        
    


# def draw_frame_with_id(self, frame_id, ego_id=None, target_id=None):

    #     #  deep copy of the image
    #     image = copy.deepcopy(self.image)

    #     #  get the frame from the tracks
    #     df_frames = self.tracks
    #     df_frames = df_frames[df_frames['frame'] == frame_id]

    #     if ego_id is not None:
    #         df_ego = df_frames[df_frames['id'] == ego_id]
    #         df_bbox = df_ego[['x', 'y', 'width', 'height']]
    #         df_bbox = df_bbox / SCALE_FACTOR
    #         x = int(df_bbox['x'])
    #         y = int(df_bbox['y'])
    #         width = int(df_bbox['width'])
    #         height = int(df_bbox['height'])
    #         cv2.rectangle(image, (x, y), (x+width, y+height), (0, 0, 255), 2)
    #         # filter the other boxes
    #         df = df_frames[df_frames['id'] != ego_id]
    #     elif target_id is not None:
    #         df_target = df_frames[df_frames['id'] == ego_id]
    #         df_bbox = df_target[['x', 'y', 'width', 'height']]
    #         df_bbox = df_bbox / SCALE_FACTOR
    #         x = int(df_bbox['x'])
    #         y = int(df_bbox['y'])
    #         width = int(df_bbox['width'])
    #         height = int(df_bbox['height'])
    #         cv2.rectangle(image, (x, y), (x+width, y+height), (255, 0, 0), 2)
    #         # filter the other boxes
    #         df = df_frames[df_frames['id'] != target_id]
    #     else:
    #         df = df_frames

    #     df_bbox = df[['x', 'y', 'width', 'height']]
    #     df_bbox = df_bbox / SCALE_FACTOR

    #     #  drawing non ego vehicles
    #     for index, row in df_bbox.iterrows():
    #         x = int(row['x'])
    #         y = int(row['y'])
    #         width = int(row['width'])
    #         height = int(row['height'])
    #         cv2.rectangle(image, (x, y), (x+width, y+height), (0, 255, 0), 2)
        
    #     return image


    # def create_video_from_frames(self, start, end, fps=25, video_name=None, ego_id=None):



    #     frameSize = (1022, 92)
    #     fourcc = cv2.VideoWriter_fourcc(*'XVID')

    #     if video_name is None:
    #         video_name = str(int(round(time.time() * 1000))) + '.avi'
    #     else:
    #         video_name = str(video_name) + '.avi'
        
    #     print('creating video with name ', video_name)

    #     out = cv2.VideoWriter(os.path.join(self.output_path, video_name), fourcc, 25, frameSize)
    #     for i in range(start, end + 1):
    #         img = self.draw_frame_with_id(i, ego_id)
    #         img = cv2.resize(img, frameSize)
    #         out.write(img)
        
    #     out.release()
        
    #     pass

    

    # def create_video_for_agent(self, video_name, agent_id):

    #     df = self.tracks
    #     df = df.loc[(df["id"] == agent_id)]
    #     frames = df["frame"].values
    #     start = frames[0]
    #     end = frames[-1]
    #     self.create_video_from_frames(start, end, fps=25, video_name=video_name, ego_id=agent_id)
    #     pass

    # def create_video_car_follow_maneuver(self):
    #     if self.car_follow is None:
    #         self.car_follow = self.filter_car_following()
        
    #     for i in range(len(self.car_follow)):
            
    #         ego_id = self.car_follow[i]['ego_id']
    #         pred_id = self.car_follow[i]['pred_id']

    #         video_name = str(self.id) + '_car_follow_' + str(ego_id) + '_' + str(pred_id)

    #         start = self.car_follow[i]['following_start']
    #         end = self.car_follow[i]['following_end']

    #         self.create_video_from_frames(start, end, 25, video_name, ego_id)
    #     pass



















    # all_frame = all_frame[0:2]

# for frame in all_frame:
#     # print(frame)
#     df_frame = df[df['frame'] == frame]
#     polygon_list = []
#     df_bbox = df_frame[['x', 'y', 'width', 'height']]
#     for index, row in df_bbox.iterrows():
#         x = row['x']
#         y = row['y']
#         width = row['width']
#         height = row['height']
#         polygon_list.append(Polygon(Point2D(x, y), Point2D(x+width, y), Point2D(x+width, y+height), Point2D(x, y+height)))
#     is_intersecting = False
#     for i in range(len(polygon_list)):
#         for j in range(i+1, len(polygon_list)):
#             if polygon_list[i].intersection(polygon_list[j]):
#                 is_intersecting = True
#                 break
#         if is_intersecting:
#             print('frame {} is intersecting'.format(frame))
#             break
    
    

# # print(all_frame)

# # df.head(10)



# print('len ', len(current_file.find_initial_state()))
# current_file.find_initial_state()
# import copy
# current_file.create_video_car_follow_maneuver()

# print(current_file)
# img = current_file.draw_frame_with_id(1)
# plt.figure(figsize = (25,2))
# plt.imshow(img, interpolation='nearest')

# current_file.create_video_from_frames('output', 1, 1000, 25)

# print(current_file.tracks.columns)

# df = current_file.tracks
# df.columns
# df.loc[(df["xVelocity"]) < 0]















print(lc_stats)
print(len(lc))
# print(len(lc['Car_yAccel_LC']))
meta_data = current_file.tracksMeta_dict
data = current_file.track_dict
print('tracks meta ', meta_data[1].keys())
print('tracks ', data[1].keys())